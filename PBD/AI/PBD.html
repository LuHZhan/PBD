<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>PBD Cloth - Impulse Interaction</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: "Segoe UI", sans-serif; }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center;
            color: #eee; pointer-events: none; user-select: none;
            text-shadow: 1px 1px 2px black; z-index: 10;
        }
        .highlight { color: #ff4444; font-weight: bold; }
    </style>
</head>
<body>
    <div id="info">
        <h2>PBD å¸ƒæ–™æ¨¡æ‹Ÿ - å†²å‡»äº’åŠ¨ç‰ˆ</h2>
        <p>ğŸ‘† <span class="highlight">å·¦é”®ç‚¹å‡»å¸ƒæ–™</span> æ–½åŠ ç‰©ç†å†²å‡» | å³é”®å¹³ç§» | æ»šè½®ç¼©æ”¾</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // ==========================================
        // 1. å‚æ•°é…ç½®
        // ==========================================
        const params = {
            width: 30,
            height: 30,
            restDistance: 0.3,
            gravity: -9.8,
            iterations: 8,
            damping: 0.99,
            windX: 0.0,
            windZ: 0.0,
            
            // å†²å‡»å‚æ•°
            impulseStrength: 40,  // å†²å‡»åŠ›åº¦
            impulseRadius: 1.5,   // å†²å‡»èŒƒå›´åŠå¾„
            
            showConstraints: false,
            shearEnabled: true,
            reset: () => initSystem()
        };

        // ==========================================
        // 2. ç‰©ç†å®šä¹‰ (PBD)
        // ==========================================
        class Particle {
            constructor(x, y, z, mass) {
                this.pos = new THREE.Vector3(x, y, z);
                this.prevPos = new THREE.Vector3(x, y, z); // ä¸Šä¸€å¸§ä½ç½®
                this.invMass = mass > 0 ? 1.0 / mass : 0;
                this.originalPos = new THREE.Vector3(x, y, z); // ç”¨äºé‡ç½®
            }

            integrate(dt) {
                if (this.invMass === 0) return;

                // Verlet ç§¯åˆ†: v = pos - prevPos
                const velocity = this.pos.clone().sub(this.prevPos).multiplyScalar(params.damping);
                
                this.prevPos.copy(this.pos);

                const force = new THREE.Vector3(params.windX, params.gravity, params.windZ);
                // ç®€å•é£åŠ›æ‰°åŠ¨
                force.x += Math.sin(Date.now() * 0.005 + this.pos.y) * 0.5;

                this.pos.add(velocity);
                this.pos.addScaledVector(force, dt * dt);
            }

            /**
             * æ–°å¢ï¼šæ–½åŠ å†²é‡
             * @param {THREE.Vector3} forceVector - å†²å‡»çš„æ–¹å‘å’Œå¤§å°
             * @param {Number} dt - æ—¶é—´æ­¥é•¿
             */
            applyImpulse(forceVector, dt) {
                if (this.invMass === 0) return;
                
                // åœ¨ PBD ä¸­ï¼Œæ”¹å˜é€Ÿåº¦çš„æ–¹æ³•æ˜¯ä¿®æ”¹ prevPos
                // v_new = v_old + impulse
                // (pos - prevPos_new)/dt = (pos - prevPos_old)/dt + impulse
                // -> prevPos_new = prevPos_old - impulse * dt
                
                this.prevPos.sub(forceVector.clone().multiplyScalar(dt));
            }
        }

        class Constraint {
            constructor(p1, p2, restDist) {
                this.p1 = p1;
                this.p2 = p2;
                this.restDist = restDist;
            }

            solve() {
                const delta = new THREE.Vector3().subVectors(this.p2.pos, this.p1.pos);
                const currentDist = delta.length();
                if (currentDist === 0) return;

                const correction = (currentDist - this.restDist) / currentDist;
                const w1 = this.p1.invMass;
                const w2 = this.p2.invMass;
                const wTotal = w1 + w2;

                if (wTotal === 0) return;

                const displacement = delta.multiplyScalar(correction);

                if (w1 > 0) this.p1.pos.addScaledVector(displacement, w1 / wTotal);
                if (w2 > 0) this.p2.pos.addScaledVector(displacement, -w2 / wTotal);
            }
        }

        // ==========================================
        // 3. åœºæ™¯ä¸æ¸²æŸ“
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // ç¯å…‰
        scene.add(new THREE.AmbientLight(0x404040));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // åœ°æ¿
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 50),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.add(floor);

        // ç‚¹å‡»ç‰¹æ•ˆæ ‡è®° (ä¸€ä¸ªå°çº¢çƒï¼Œç‚¹å‡»æ—¶å‡ºç°)
        const hitMarkerGeo = new THREE.SphereGeometry(0.2, 8, 8);
        const hitMarkerMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 });
        const hitMarker = new THREE.Mesh(hitMarkerGeo, hitMarkerMat);
        scene.add(hitMarker);

        // ==========================================
        // 4. ç³»ç»Ÿåˆå§‹åŒ–
        // ==========================================
        let particles = [];
        let constraints = [];
        let clothMesh, clothGeometry, constraintsLine;

        function initSystem() {
            if (clothMesh) { scene.remove(clothMesh); clothGeometry.dispose(); }
            if (constraintsLine) { scene.remove(constraintsLine); }

            particles = [];
            constraints = [];
            const w = params.width;
            const h = params.height;

            // åˆ›å»ºç²’å­
            for (let y = 0; y <= h; y++) {
                for (let x = 0; x <= w; x++) {
                    const xPos = (x - w / 2) * params.restDistance;
                    const yPos = 8 - y * params.restDistance;
                    
                    // å›ºå®šé¡¶éƒ¨ 3 ä¸ªç‚¹
                    let mass = 1.0;
                    if (y === 0 && (x === 0 || x === w || x === Math.floor(w/2))) mass = 0;

                    particles.push(new Particle(xPos, yPos, 0, mass));
                }
            }

            const getIndex = (x, y) => y * (w + 1) + x;

            // åˆ›å»ºçº¦æŸ
            for (let y = 0; y <= h; y++) {
                for (let x = 0; x <= w; x++) {
                    const idx = getIndex(x, y);
                    // ç»“æ„çº¦æŸ
                    if (x < w) constraints.push(new Constraint(particles[idx], particles[getIndex(x + 1, y)], params.restDistance));
                    if (y < h) constraints.push(new Constraint(particles[idx], particles[getIndex(x, y + 1)], params.restDistance));
                    // å‰ªåˆ‡çº¦æŸ
                    if (params.shearEnabled && x < w && y < h) {
                        const diag = params.restDistance * Math.sqrt(2);
                        constraints.push(new Constraint(particles[idx], particles[getIndex(x+1, y+1)], diag));
                        constraints.push(new Constraint(particles[getIndex(x+1, y)], particles[getIndex(x, y+1)], diag));
                    }
                }
            }

            // åˆ›å»ºç½‘æ ¼
            clothGeometry = new THREE.PlaneGeometry(1, 1, w, h);
            const clothMat = new THREE.MeshStandardMaterial({ 
                color: 0x3498db, 
                side: THREE.DoubleSide, 
                flatShading: true,
                roughness: 0.6
            });
            clothMesh = new THREE.Mesh(clothGeometry, clothMat);
            clothMesh.castShadow = true;
            clothMesh.frustumCulled = false;
            scene.add(clothMesh);

            // åˆ›å»ºçº¦æŸçº¿
            const lineGeo = new THREE.BufferGeometry();
            lineGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(constraints.length * 6), 3));
            constraintsLine = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({ color: 0xffff00, opacity: 0.4, transparent: true }));
            constraintsLine.visible = params.showConstraints;
            constraintsLine.frustumCulled = false;
            scene.add(constraintsLine);
        }

        // ==========================================
        // 5. ç‰©ç†ä¸æ¸²æŸ“å¾ªç¯
        // ==========================================
        const fixedTimeStep = 0.016;

        function updatePhysics() {
            for (let p of particles) p.integrate(fixedTimeStep);
            for (let i = 0; i < params.iterations; i++) {
                for (let c of constraints) c.solve();
            }
        }

        function updateMeshes() {
            const posAttr = clothGeometry.attributes.position;
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i].pos;
                posAttr.setXYZ(i, p.x, p.y, p.z);
            }
            posAttr.needsUpdate = true;
            clothGeometry.computeVertexNormals();

            if (params.showConstraints && constraintsLine.visible) {
                const linePos = constraintsLine.geometry.attributes.position.array;
                let idx = 0;
                for (let c of constraints) {
                    linePos[idx++] = c.p1.pos.x; linePos[idx++] = c.p1.pos.y; linePos[idx++] = c.p1.pos.z;
                    linePos[idx++] = c.p2.pos.x; linePos[idx++] = c.p2.pos.y; linePos[idx++] = c.p2.pos.z;
                }
                constraintsLine.geometry.attributes.position.needsUpdate = true;
            }

            // æ·¡å‡ºç‚¹å‡»ç‰¹æ•ˆ
            if (hitMarker.material.opacity > 0) {
                hitMarker.material.opacity -= 0.05;
                hitMarker.scale.multiplyScalar(1.1); // æ‰©æ•£åŠ¨ç”»
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateMeshes();
            controls.update();
            renderer.render(scene, camera);
        }

        // ==========================================
        // 6. äº’åŠ¨é€»è¾‘ (Raycasting & Impulse)
        // ==========================================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', (event) => {
            // åªå“åº”å·¦é”® (0)
            if (event.button !== 0) return;

            // 1. è®¡ç®—é¼ æ ‡åæ ‡ (-1 åˆ° 1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // 2. æŠ•å°„å…‰çº¿
            raycaster.setFromCamera(mouse, camera);
            
            // 3. æ£€æµ‹æ˜¯å¦å‡»ä¸­å¸ƒæ–™
            const intersects = raycaster.intersectObject(clothMesh);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const hitPoint = hit.point;
                const rayDir = raycaster.ray.direction.clone().normalize(); // å†²å‡»æ–¹å‘ (æ‘„åƒæœºæœå‘)

                // è§†è§‰åé¦ˆ
                hitMarker.position.copy(hitPoint);
                hitMarker.scale.set(1, 1, 1);
                hitMarker.material.opacity = 1.0;

                // 4. ç‰©ç†è®¡ç®—ï¼šå¯»æ‰¾èŒƒå›´å†…çš„ç²’å­å¹¶æ–½åŠ å†²é‡
                // æˆ‘ä»¬ä¸ä¾èµ– face indexï¼Œè€Œæ˜¯ç®€å•çš„æ ¹æ®è·ç¦» (Splash Damage)
                for (let p of particles) {
                    const dist = p.pos.distanceTo(hitPoint);
                    
                    if (dist < params.impulseRadius) {
                        // è·ç¦»è¡°å‡ï¼šä¸­å¿ƒç‚¹å—åŠ›æœ€å¤§
                        const falloff = 1.0 - (dist / params.impulseRadius);
                        
                        // æ„é€ å†²å‡»å‘é‡ï¼šæ–¹å‘ * åŠ›åº¦ * è¡°å‡
                        const impulse = rayDir.clone().multiplyScalar(params.impulseStrength * falloff);
                        
                        p.applyImpulse(impulse, fixedTimeStep);
                    }
                }
            }
        });

        // ==========================================
        // 7. GUI æ§åˆ¶
        // ==========================================
        initSystem();
        animate();

        const gui = new GUI({ title: "æ§åˆ¶é¢æ¿" });
        
        const fInter = gui.addFolder('ğŸ–ï¸ äº’åŠ¨è®¾ç½®');
        fInter.add(params, 'impulseStrength', 10, 100).name('å†²å‡»åŠ›åº¦');
        fInter.add(params, 'impulseRadius', 0.5, 5.0).name('å†²å‡»åŠå¾„');

        const fSim = gui.addFolder('âš™ï¸ æ¨¡æ‹Ÿå‚æ•°');
        fSim.add(params, 'gravity', -20, 2).name('é‡åŠ›');
        fSim.add(params, 'windX', -5, 5).name('é£åŠ› X');
        fSim.add(params, 'shearEnabled').name('å¯ç”¨æŠ—å‰ªåˆ‡').onChange(initSystem);

        const fDebug = gui.addFolder('ğŸ‘€ è§†è§‰è°ƒè¯•');
        fDebug.add(params, 'showConstraints').name('æ˜¾ç¤ºçº¦æŸ').onChange(v => constraintsLine.visible = v);
        fDebug.add(clothMesh.material, 'wireframe').name('ç½‘æ ¼çº¿æ¡†');

        gui.add(params, 'reset').name('é‡ç½®æ¨¡æ‹Ÿ');

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>